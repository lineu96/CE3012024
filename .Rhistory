x.pred$xloess <- predict(yloess, newdata = x.pred)
with(x.pred, lines(x, xloess, col = '#008000', lwd = 2))
## Spline
library(splines)
yspline <- lm(y~bs(x), data = plantas)
x.pred$xspline <- predict(yspline, newdata = x.pred)
with(x.pred, lines(x, xspline, col = '#4B0082', lwd = 2))
## Segmentada
fit <- lm(y ~ x, data=plantas)
segmented.fit <- segmented(fit, seg.Z = ~x)
#----------------------------------------------------------------------
par(mfrow=c(2,3), mar = c(3, 3, 0.5, 0.5), mgp=c(2, 0.8, 0))
#----------------------------------------------------------------------
# Exemplo 1: crescimento de planta
plantas <- data.frame(x = 1:7, y = c(5,13,16,23,33,38,40))
plot(y~x, data=plantas, xlab = 'Idade da planta (semanas)',
ylab = 'Altura (cm)', pch = 20, cex = 1.4, ylim = c(0,45),
col = 'grey60')
x.pred <- data.frame(x = seq(0, 8, 0.05))
## Regressão linear simples
abline(lm(y~x, data=plantas), lwd = 2)
## Regressão ponimial de grau 3
y3 <- lm(y ~ poly(x, 3), data = plantas)
x.pred$x3 <- predict(y3, newdata = x.pred)
with(x.pred, lines(x, x3, col = 'blue', lwd = 2))
## Regressão ponimial de grau 6
y6 <- lm(y ~ poly(x, 6), data = plantas)
x.pred$x6 <- predict(y6, newdata = x.pred)
with(x.pred, lines(x, x6, col = 'red', lwd = 2))
## Loess
yloess <- loess(y~x, data = plantas)
x.pred$xloess <- predict(yloess, newdata = x.pred)
with(x.pred, lines(x, xloess, col = '#008000', lwd = 2))
## Spline
library(splines)
yspline <- lm(y~bs(x), data = plantas)
x.pred$xspline <- predict(yspline, newdata = x.pred)
with(x.pred, lines(x, xspline, col = '#4B0082', lwd = 2))
## Segmentada
library(segmented)
fit <- lm(y ~ x, data=plantas)
segmented.fit <- segmented(fit, seg.Z = ~x)
plot(segmented.fit, add=T, col = '#D2691E', lwd = 2)
#----------------------------------------------------------------------
# Exemplo 2: corrosão para diferentes teores de ferro
require(faraway)
data(corrosion)
plot(loss~Fe, data=corrosion, pch = 20, cex = 1.4,col = 'grey60')
Fe.pred <- data.frame(Fe = seq(0, 2, 0.05))
## Regressão linear simples
abline(lm(loss~Fe, data=corrosion), lwd = 2)
## Regressão ponimial de grau 3
Fe3 <- lm(loss ~ poly(Fe, 3), data = corrosion)
Fe.pred$Fe3 <- predict(Fe3, newdata = Fe.pred)
with(Fe.pred, lines(Fe, Fe3, col = 'blue', lwd = 2))
## Regressão ponimial de grau 6
Fe6 <- lm(loss ~ poly(Fe, 6), data = corrosion)
Fe.pred$Fe6 <- predict(Fe6, newdata = Fe.pred)
with(Fe.pred, lines(Fe, Fe6, col = 'red', lwd = 2))
## Loess
lossloess <- loess(loss~Fe, data = corrosion)
Fe.pred$Feloess <- predict(lossloess, newdata = Fe.pred)
with(Fe.pred, lines(Fe, Feloess, col = '#008000', lwd = 2))
## Spline
library(splines)
lossspline <- lm(loss~bs(Fe), data = corrosion)
Fe.pred$Fespline <- predict(lossspline, newdata = Fe.pred)
with(Fe.pred, lines(Fe, Fespline, col = '#4B0082', lwd = 2))
## Segmentada
fit <- lm(loss ~ Fe, data=corrosion)
segmented.fit <- segmented(fit, seg.Z = ~Fe)
plot(segmented.fit, add=T, col = '#D2691E', lwd = 2)
#----------------------------------------------------------------------
## Exemplo 3: peso corporal e do coração de gatos
require(MASS)
data(cats)
plot(Hwt ~ Bwt, data = cats, xlab = 'Peso corporal (kg)',
ylab = 'Peso do coração (g)', pch = 20, cex = 1.4, col = 'grey60')
Bwt.pred <- data.frame(Bwt = seq(1, 5, 0.05))
## Regressão linear simples
abline(lm(Hwt~Bwt, data=cats), lwd = 2)
## Regressão ponimial de grau 3
Hwt3 <- lm(Hwt ~ poly(Bwt, 3), data = cats)
Bwt.pred$Bwt3 <- predict(Hwt3, newdata = Bwt.pred)
with(Bwt.pred, lines(Bwt, Bwt3, col = 'blue', lwd = 2))
## Regressão ponimial de grau 6
Hwt6 <- lm(Hwt ~ poly(Bwt, 6), data = cats)
Bwt.pred$Bwt6 <- predict(Hwt6, newdata = Bwt.pred)
with(Bwt.pred, lines(Bwt, Bwt6, col = 'red', lwd = 2))
## Loess
Hwtloess <- loess(Hwt~Bwt, data = cats)
Bwt.pred$Bwtloess <- predict(Hwtloess, newdata = Bwt.pred)
with(Bwt.pred, lines(Bwt, Bwtloess, col = '#008000', lwd = 2))
## Spline
library(splines)
Hwtspline <- lm(Hwt~bs(Bwt), data = cats)
Bwt.pred$Bwtspline <- predict(Hwtspline, newdata = Bwt.pred)
with(Bwt.pred, lines(Bwt, Bwtspline, col = '#4B0082', lwd = 2))
## Segmentada
fit <- lm(Hwt ~ Bwt, data=cats)
segmented.fit <- segmented(fit, seg.Z = ~Bwt, npsi = 2)
plot(segmented.fit, add=T, col = '#D2691E', lwd = 2)
#----------------------------------------------------------------------
# Exemplo 4: tempo de erupção vs intervalo de tempo entre erupções
plot(eruptions ~ waiting, data = faithful, pch = 20, cex = 1.4, col = 'grey60',
xlab = 'Tempo desde a última erupção',
ylab = 'Duração da erupção')
waiting.pred <- data.frame(waiting = seq(40, 100, 0.05))
## Regressão linear simples
abline(lm(eruptions~waiting, data=faithful), lwd = 2)
## Regressão ponimial de grau 3
eruptions3 <- lm(eruptions ~ poly(waiting, 3), data = faithful)
waiting.pred$waiting3 <- predict(eruptions3, newdata = waiting.pred)
with(waiting.pred, lines(waiting, waiting3, col = 'blue', lwd = 2))
## Regressão ponimial de grau 6
eruptions6 <- lm(eruptions ~ poly(waiting, 6), data = faithful)
waiting.pred$waiting6 <- predict(eruptions6, newdata = waiting.pred)
with(waiting.pred, lines(waiting, waiting6, col = 'red', lwd = 2))
## Loess
eruptionsloess <- loess(eruptions~waiting, data = faithful)
waiting.pred$waitingloess <- predict(eruptionsloess, newdata = waiting.pred)
with(waiting.pred, lines(waiting, waitingloess, col = '#008000', lwd = 2))
# Splines
library(splines)
library(splines)
eruptionsspline <- lm(eruptions~bs(waiting), data = faithful)
waiting.pred$waitingspline <- predict(eruptionsspline, newdata = waiting.pred)
with(waiting.pred, lines(waiting, waitingspline, col = '#4B0082', lwd = 2))
## Segmentada
fit <- lm(eruptions ~ waiting, data=faithful)
segmented.fit <- segmented(fit, seg.Z = ~waiting, npsi = 2)
plot(segmented.fit, add=T, col = '#D2691E', lwd = 2)
#----------------------------------------------------------------------
## Exemplo 5: escore está relacionado com a renda?
require(AER)
data("CASchools")
CASchools$lincome <- log(CASchools$income)
plot(math~lincome, data=CASchools,
xlab = 'Renda média do distrito (em log(U$1.000))',
ylab = 'Escore médio (Matemática)',
pch = 20, col = 'grey60', cex = 1.4)
lincome.pred <- data.frame(lincome = seq(1.6, 4.1, 0.05))
## Regressão linear simples
abline(lm(math~lincome, data=CASchools), lwd = 2)
## Regressão ponimial de grau 3
math3 <- lm(math ~ poly(lincome, 3), data = CASchools)
lincome.pred$lincome3 <- predict(math3, newdata = lincome.pred)
with(lincome.pred, lines(lincome, lincome3, col = 'blue', lwd = 2))
## Regressão ponimial de grau 6
math6 <- lm(math ~ poly(lincome, 6), data = CASchools)
lincome.pred$lincome6 <- predict(math6, newdata = lincome.pred)
with(lincome.pred, lines(lincome, lincome6, col = 'red', lwd = 2))
## Loess
mathloess <- loess(math~lincome, data = CASchools)
lincome.pred$lincomeloess <- predict(mathloess, newdata = lincome.pred)
with(lincome.pred, lines(lincome, lincomeloess, col = '#008000', lwd = 2))
## Spline
library(splines)
mathspline <- lm(math~bs(lincome), data = CASchools)
lincome.pred$xspline <- predict(mathspline, newdata = lincome.pred)
with(lincome.pred, lines(lincome, xspline, col = '#4B0082', lwd = 2))
## Segmentada
fit <- lm(math ~ lincome, data=CASchools)
segmented.fit <- segmented(fit, seg.Z = ~lincome, npsi = 3)
plot(segmented.fit, add=T, col = '#D2691E', lwd = 2)
#----------------------------------------------------------------------
# Exemplo 6: energia gerada para diferentes velocidades de vento
eolica <- data.frame(
wind = c(5.00, 6.00, 3.40, 2.70, 10.0, 9.70, 9.55, 3.05, 8.15, 6.20, 2.90, 6.35, 4.60, 5.80, 7.40, 3.60, 7.85, 8.80, 7.00, 5.45, 9.10, 10.2, 4.10, 3.95, 2.45),
energy = c(1.582, 1.822, 1.057, 0.500, 2.236, 2.386, 2.294, 0.558, 2.166, 1.866, 0.653, 1.930, 1.562, 1.737, 2.088, 1.137, 2.179, 2.112, 1.800, 1.501, 2.303, 2.310, 1.194, 1.144, 0.123)#^2
)
plot(energy ~ wind, data = eolica,
pch = 20, cex = 1.4, las = 1, col = 'grey60')
wind.pred <- data.frame(wind = seq(2, 11, 0.05))
## Regressão linear simples
abline(lm(energy~wind, data=eolica), lwd = 2)
## Regressão ponimial de grau 3
energy3 <- lm(energy ~ poly(wind, 3), data = eolica)
wind.pred$wind3 <- predict(energy3, newdata = wind.pred)
with(wind.pred, lines(wind, wind3, col = 'blue', lwd = 2))
## Regressão ponimial de grau 6
energy6 <- lm(energy ~ poly(wind, 6), data = eolica)
wind.pred$wind6 <- predict(energy6, newdata = wind.pred)
with(wind.pred, lines(wind, wind6, col = 'red', lwd = 2))
## Loess
energyloess <- loess(energy~wind, data = eolica)
wind.pred$windloess <- predict(energyloess, newdata = wind.pred)
with(wind.pred, lines(wind, windloess, col = '#008000', lwd = 2))
## Splines
library(splines)
energyspline <- lm(energy~bs(wind), data = eolica)
wind.pred$windspline <- predict(energyspline, newdata = wind.pred)
with(wind.pred, lines(wind, windspline, col = '#4B0082', lwd = 2))
## Segmentada
fit <- lm(energy ~ wind, data=eolica)
segmented.fit <- segmented(fit, seg.Z = ~wind, npsi = 2)
plot(segmented.fit, add=T, col = '#D2691E', lwd = 2)
#----------------------------------------------------------------------
293.59-244.2
# Exemplo 1: crescimento de planta
plantas <- data.frame(x = 1:7, y = c(5,13,16,23,33,38,40))
plot(y~x, data=plantas, xlab = 'Idade da planta (semanas)',
ylab = 'Altura (cm)', pch = 20, cex = 1.4, ylim = c(0,45),
col = 'grey60')
x.pred <- data.frame(x = seq(0, 8, 0.05))
## Regressão linear simples
abline(lm(y~x, data=plantas), lwd = 2)
## Regressão ponimial de grau 3
y3 <- lm(y ~ poly(x, 3), data = plantas)
x.pred$x3 <- predict(y3, newdata = x.pred)
with(x.pred, lines(x, x3, col = 'blue', lwd = 2))
## Regressão ponimial de grau 6
y6 <- lm(y ~ poly(x, 6), data = plantas)
x.pred$x6 <- predict(y6, newdata = x.pred)
with(x.pred, lines(x, x6, col = 'red', lwd = 2))
## Loess
yloess <- loess(y~x, data = plantas)
x.pred$xloess <- predict(yloess, newdata = x.pred)
with(x.pred, lines(x, xloess, col = '#008000', lwd = 2))
## Spline
library(splines)
yspline <- lm(y~bs(x), data = plantas)
x.pred$xspline <- predict(yspline, newdata = x.pred)
with(x.pred, lines(x, xspline, col = '#4B0082', lwd = 2))
## Segmentada
library(segmented)
fit <- lm(y ~ x, data=plantas)
segmented.fit <- segmented(fit, seg.Z = ~x)
plot(segmented.fit, add=T, col = '#D2691E', lwd = 2)
# Exemplo 2: corrosão para diferentes teores de ferro
require(faraway)
data(corrosion)
plot(loss~Fe, data=corrosion, pch = 20, cex = 1.4,col = 'grey60')
## Exemplo 3: peso corporal e do coração de gatos
require(MASS)
data(cats)
plot(Hwt ~ Bwt, data = cats, xlab = 'Peso corporal (kg)',
ylab = 'Peso do coração (g)', pch = 20, cex = 1.4, col = 'grey60')
# Exemplo 4: tempo de erupção vs intervalo de tempo entre erupções
plot(eruptions ~ waiting, data = faithful, pch = 20, cex = 1.4, col = 'grey60',
xlab = 'Tempo desde a última erupção',
ylab = 'Duração da erupção')
waiting.pred <- data.frame(waiting = seq(40, 100, 0.05))
## Regressão linear simples
abline(lm(eruptions~waiting, data=faithful), lwd = 2)
## Segmentada
fit <- lm(eruptions ~ waiting, data=faithful)
segmented.fit <- segmented(fit, seg.Z = ~waiting, npsi = 2)
plot(segmented.fit, add=T, col = '#D2691E', lwd = 2)
y <- c(8.0,10.0, 11.0, 12.0,13.0,14.0)
p <- c(0.1,0.2,0.2,0.3,0.1,0.1)
tb <- data.frame(y,p)
#B)Obtenha média, variância e desvio padrão da variável aleatória
x <- y*p
media <- sum(x)
var <- sum((media-y)^2*p)
dp <- sqrt(var)
#C)Obtenha P(Y < 11)
sum(p[y<11])
#D)Obtenha P(Y ≥ 12).
sum(p[y>=12])
#E)Obtenha P(12 < Y ≤ 13)
sum(p[y>12 & y<=13])
#F)Obtenha P(Y ≤ 12|Y ≥ 8)
sum(p[y<=12 & Y>=8])/sum(p[y>=8])
#F)Obtenha P(Y ≤ 12|Y ≥ 8)
sum(p[y<=12 & Y>=8])/sum(p[y>=8])
#F)Obtenha P(Y ≤ 12|Y ≥ 8)
sum(p[y<=12 & y>=8])/sum(p[y>=8])
P <- (1*0.2)
P
P1 <- (1*0.2)
P2 <- (2*0.05)
P3 <- (1*0.25)
P4 <- (P1+P2+P3)
P <- (1*0.05)/((2*0.05)+(2*0.2))
P
P <- pbinom(10,10,0.2) - pbinom(5,10,0.2)
P
p <- 0.2
n <- 10
var <- n*p*(1-p)
dp <- sqrt(var)
e <- n*p
e
dp
P <- pbinom(10,10,0.25) - pbinom(5,10,0.25)
P
P <- pnorm(82,82,15,lower.tail = TRUE, log.p = FALSE)
P
P <-  pnorm(120, 82, 15, lower.tail = TRUE, log.p = FALSE)
P <- 1-P
P <- qnorm(.99,82,15,lower.tail = TRUE, log.p = FALSE)
P
#A) O que é um modelo de probabilidade?
rm(list=ls())
Y <- c(8.0, 10.0, 11.0, 12.0, 13.0, 14.0)
P_Y <- c(0.1, 0.2, 0.2, 0.3, 0.1, 0.1)
funcao <- data.frame(Y,P_Y)
funcao
names(funcao) <- c("Var.","Prob.")
# para testar i) para todos y em Y, itero para cada um dos valores de y usando um laço for.
#se y>1 ou y<0, a variável teste assume valor false
teste=T
for (i in 1:length("Prob.")){
if (P_Y[i]<0 | P_Y[i]>1){teste=F}
}
#para testar a hipótese ii), basta somar os valores do vetor P_Y.
#testo então se a função satisfaz ambas as propriedades
if (teste == FALSE | sum(P_Y)>1){I-a <- "Não é uma função de probabilidade"} else {I_a <- "É uma função de probabilidade"}
media <- sum(P_Y*Y)
media
I_b <- round(media,3)
variancia = 0
for (i in 1:length(P_Y)){variancia = ((Y[i]-media)^2)*P_Y[i]+variancia}
variancia
I_b[2] <- round(variancia,3)
#o desvio padrão é a raiz quadrada da variâmcia
dp = sqrt(variancia)
dp
I_b[3] <- round(dp,3)
acumulada <- function(func,min,max){
minn = which(func$"Var."==min)
maxx = which(func$"Var."==max)
p <- sum(c(func$"Prob."[minn:maxx]))
p
return(p)}
prob_a <- acumulada(funcao,8,10)
I_c <- prob_a
I_c
prob_d <-acumulada(funcao,12,14)
prob_d
I_d <- prob_d
I_d
#e) Obtenha P(12 < Y ≤ 13)
#neste caso, a função é apenas P(13): 0.1
I_e <- 0.1
inter_8_12 <- acumulada(funcao,8,12)
prob_8 <- acumulada(funcao,8,14)
prob_f <- inter_8_12/prob_8
prob_f
I_f <- prob_f
fdp <- function(x) {
ifelse(x < 0, 0,
ifelse(x < 2, 0.2,
ifelse(x < 4, 0.05,
ifelse(x<6,0.25,0))))
}
y <- seq(-1, 7, by=0.0001)
fdp_graf <- fdp(y)
plot(y, fdp_graf, type= "l", lty=1, lwd = 0.5,main = "Função Densidade de Probabilidade", xlab = "y", ylab = "F(y)")
grid()
II_a <- "Ver linhas #128 a #141"
fdp_intervalos <- function(min,max){if(max < 0 | max > 6 |min < 0 | min > 6){p="A função não está definida em todo este intervalo"}else if
(max<=2 && min>=0){p=0.2*(max-min)}else if(max<=4 && min>2)
{p=0.05*(max-min)}else if(max<=6 && min>=4){p=0.25*(max-min)}else if
(max>2 && max <= 4 && min<=2){p=0.05*(max-2)+0.2*(2-min)}else if
(max>4 && min<=2){p=0.2*(2-min) + 0.05*(4-2) + 0.25*(max - 4)}else if
(max>4 && min<=4 && min>2){p=0.2*(2-0) + 0.05*(min-2) + 0.25*(max - 4)}else if
(min==max){p=0}else{0}
return(p)
}
hipotese_i <- fdp(0:6)
hipotese_i
teste = T
for (k in 1:length(hipotese_i)){if(hipotese_i[k]>1|hipotese_i[k]<0){teste=F}}
# ii) Para testar a segunda hipótese, basta calcular a integral definidade entre 0 e 6
area <- integrate(fdp,0,6)
area
area <- area$value
if(teste==T && area == 1){II_b <- "É uma FDP"}else{II_b <- "Não é uma FDP"}
#c) Qual é a probabilidade da variável aleatória Y assumir valores menores ou iguais a 1?
prob_c <- fdp_intervalos(0,1)
prob_c
II_c <- round(prob_c,3)
#d) Qual é a probabilidade da variável aleatória Y assumir valores entre 1 e 5?
prob_d <- fdp_intervalos(1,5)
prob_d
II_d <- round(prob_d,3)
#Usando a regra do condicional
#definimos a interseção entre os intervalos y>=3 e y<=4
prob_int <- fdp_intervalos(3,4) #(1)
prob_int
#calculamos a probabilidade do intervalo de 0 até 4
prob_0_4 <- fdp_intervalos(0,4) #(2)
prob_0_4
#basta dividir (1) por (2)
prob_e <- prob_int/prob_0_4
prob_e
II_e <- round(prob_e,3)
#A probabilidade de acertar 6 questões é dada por:
questoes <- 1:10
size=10
p = 1/5
aprov <- dbinom(questoes, size, p)
prob <- data.frame(questoes,aprov)
prob_a <- prob[6,2]
prob_a
III_a <- round(prob_a,3)
#b) Para o cenário descrito no item (a) qual é o número esperado de acertos? Qual o desvio padrão? (0,5)
#Para uma distribuição de probabildiade bonomial, o número de acertos esperada é a esperança E(y)
E <- size*p
E
#o desvio padrão é np(1-p)
S <- E*(1-p)
S
III_b <- paste("Esperança:",as.character(E),"   Desvio padrão:",as.character(S))
#c) Qual a probabilidade de aprovação se os seus conhecimentos lhe permitem eliminar uma opção de cada
#questão? (0,5 ponto)
# a resolução é análoga à da alternativa a, mas agora com p=1/4
questoes <- 1:10
size=10
p = 1/4
aprov <- dbinom(questoes, size, p)
prob <- data.frame(questoes,aprov)
prob_a <- prob[6,2]
prob_a
III_c <- round(prob_a,3)
#a) Qual a proporção de candidatos levará menos de 82 minutos para fazer o teste? (0,5 ponto)
IV_a <- "Metade, ou 50%, pois a distribuiição normal é simétrica em torno da média"
# P(X > 120)
abline(v = 120)
IV_b <- round((1-pnorm(q = 120, mean = 82, sd = sqrt(225))),3)
IV_b
maior_t <- qnorm(0.99, mean = 82, sd = 15)
maior_t
IV_c <- maior_t
#a) O que é um modelo de probabilidade? (0,5 ponto)
V_a <- "Um modelo de probabilidade é uma representação matemática, aproximada ou exata, de um determinado experimento\nou fenômeno de natureza aleatória.  Na prática, é uma função matemática cujo domínio são os valores de uma determinada
variável aleatória e o conjunto de parâmetros particulares de cada modelo de distribuição, cujos valores são definidos\n
pelas características do fenômeno estudado"
V_b <-  "A distribuição normal descreve muitos fenômenos aleatórios, especialmente aqueles com distribuição simétrica em torno
da média. A facilidade de cálculo utilizando tabelas padronizadas facilita muito a obtenção de valores associados à fenômenos"
V_c <- "BINOMIAL: descreve experimentos que tem resultados do tipo sucesso e fracasso feitos de forma repetida. É interessante para\n prever eficácia de vacinas e medicamentos, previsões meteorológicas etc.\nPOISSON: expressa o possível tempo de ocorrência de um evento em situações em que há taxas fixas e independência entre
variáveis. É útil em áreas como a análise de sobrevivência"
Prova_3 <- c("Prova - 3",paste("I_a: ",I_a),
paste("I_b: ",I_b),
paste("I_c: ",I_c),
paste("I_d: ",I_d),
paste("I_e: ",I_e),
paste("I_f: ",I_f),
paste("II_a",II_a),
paste("II_b: ",II_b),
paste("II_c: ", II_c),
paste("II_d: ", II_d),
paste("II_e: ", II_e),
paste("III_a: ",III_a),
paste("III_b: ",III_b),
paste("III_c: ", III_c),
paste("IV_a: ", IV_a),
paste("IV_b: ", IV_b),
paste("IV_c: ", IV_c),
paste("V_a: ", V_a),
paste("V_b: ", V_b),
paste("V_c: ", V_c))
Prova_3
Prova_3
Y <- c(8.0,10.0, 11.0, 12.0,13.0,14.0)
P <- c(0.1,0.2,0.2,0.3,0.1,0.1)
tb <- data.frame(y,p)
#B)
x <- y*p
media <- sum(x)
var <- sum((media-y)^2*p)
dp <- sqrt(var)
#C)
sum(p[y<11])
#D)
sum(p[y>=12])
#E)
sum(p[y>12 & y<=13])
#F)
sum(P[Y<=12 & Y>=8])/sum(P[Y>=8])
Y <- c(8.0,10.0, 11.0, 12.0,13.0,14.0)
P <- c(0.1,0.2,0.2,0.3,0.1,0.1)
tb <- data.frame(y,p)
#B)
x <- y*p
media <- sum(x)
var <- sum((media-y)^2*p)
dp <- sqrt(var)
media
var
dp
P <- (1*0.2)
P
P1 <- (1*0.2)
P2 <- (2*0.05)
P3 <- (1*0.25)
P4 <- (P1+P2+P3)
P <- (1*0.05)/((2*0.05)+(2*0.2))
P4
P <- (1*0.05)/((2*0.05)+(2*0.2))
P
P <- dbinom(6,10,0.2) + dbinom(7,10,0.2) + dbinom(8,10,0.2) + dbinom(9,10,0.2) + dbinom(10,10,0.2)
P <- pbinom(10,10,0.2) - pbinom(5,10,0.2)
P
p <- 0.2
n <- 10
dp <- n*p*(1-p)
e <- n*p
P <- pbinom(10,10,0.25) - pbinom(5,10,0.25)
P <- pnorm(82,82,15,lower.tail = TRUE, log.p = FALSE)
P <-  pnorm(120, 82, 15, lower.tail = TRUE, log.p = FALSE)
P <- 1-P
P <- qnorm(.99,82,15,lower.tail = TRUE, log.p = FALSE)
setwd("~/CE3012024")
rmarkdown::render_site()
rmarkdown::render_site()
rmarkdown::render_site()
setwd("~/CE3012024")
rmarkdown::render_site()
